#!/usr/bin/env python

PACKAGE = "volti"
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()

# Parametros del controldor de velocidad PID, el rango del PWM de salida es 100 * 100, por lo cual
# el 20% del total seria de 2000 unidades, el entero deseado es un Int16, que llega al microcontrolador
# como el valor en microsegundos para dar salida al servo, usaremos la clase que me permita dar una valor
# de pulso de alta precision en lugar de usar ticks al estilo de arduino, el valor puede ir de -32000
# a 32000, pero bueno, no deseamos llegar a esos valores en realidad
gen.add("kp_pos", double_t, 0, "kp, out+=kp*err",                       0,   0, 100)
gen.add("ki_pos", double_t, 0, "ki, out+=ki*sum(err)",                  0,   0, 100)
gen.add("kd_pos", double_t, 0, "kd, out+=kd*diff(err)",                 0,   0, 100)
gen.add("km_pos", double_t, 0, "km, out+=km*des",                       0,   0, 100)
gen.add("umbral_pos", double_t, 0, "if err<umbral then err=0 ",         0,   0, 1)
gen.add("ki_dec_pos", double_t, 0, "ki reverse penalty mode",           0,   0, 100)
gen.add("range_pos",  double_t, 0, "max pwm in mode",                   0,   0, 1000)

gen.add("kp_vel", double_t, 0, "kp, out+=kp*err",                       0,   0, 100)
gen.add("ki_vel", double_t, 0, "ki, out+=ki*sum(err)",                  0,   0, 100)
gen.add("kd_vel", double_t, 0, "kd, out+=kd*diff(err)",                 0,   0, 100)
gen.add("km_vel", double_t, 0, "km, out+=km*des",                       0,   0, 100)
gen.add("umbral_vel", double_t, 0, "if err<umbral then err=0 ",         0,   0, 1)
gen.add("ki_dec_vel", double_t, 0, "ki reverse penalty mode",           0,   0, 100)
gen.add("range_vel",  double_t, 0, "max pwm in mode",                   0,   0, 1000)

exit(gen.generate(PACKAGE, "volti", "PID"))

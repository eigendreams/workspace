#!/usr/bin/env python

PACKAGE = "volti"
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()

# Parametros del controldor de velocidad PID, el rango del PWM de salida es 100 * 100, por lo cual
# el 20% del total seria de 2000 unidades, el entero deseado es un Int16, que llega al microcontrolador
# como el valor en microsegundos para dar salida al servo, usaremos la clase que me permita dar una valor
# de pulso de alta precision en lugar de usar ticks al estilo de arduino, el valor puede ir de -32000
# a 32000, pero bueno, no deseamos llegar a esos valores en realidad
# En los programas todo se hace en valores de porcentaje de -100 a 100, indicando sentido con el signo
# ausmiendo el valor maximo de salida del 20% a 0.1 radianes de error
# No quiero dar una salida de los motores superior al 20%
# asumiendo que los motores pueden consumir el 20% de PWM con rotor parado indefinidamente
# la parte de ki indica el cambio de porcentaje por segundo por el error
# a un error de 0.1 radianes un cambio del 1 por ciento necesita de 10 segundos si ki fuera de 1
# a un error de 0.1 radianes un cambio del 5 porciento necesita de 2.5 segundos si ki fuera de 20
# el control de velocidad tiene km, que es del modelo del motor

gen.add("kp0rps_pos", double_t, 0, "kp, out+=kp*err",                   0,   0, 300)
gen.add("kp1rps_pos", double_t, 0, "kp, out+=kp*err",                   0,   0, 300)
gen.add("ki_pos",     double_t, 0, "ki, out+=ki*sum(err)",              0,   0, 30)
gen.add("kd_pos",     double_t, 0, "kd, out+=kd*diff(err)",             0, -30, 30)
gen.add("umbral_pos", double_t, 0, "if err<umbral then err=0 ",         0,   0, 1)
gen.add("ki_dec_pos", double_t, 0, "ki reverse penalty mode",           0,   0, 30)
gen.add("range_pos",  double_t, 0, "max pwm in mode",                   0,   0, 30)

gen.add("kp_vel",     double_t, 0, "kp, out+=kp*err",                   0,   0, 300)
gen.add("ki_vel",     double_t, 0, "ki, out+=ki*sum(err)",              0,   0, 30)
gen.add("kd_vel",     double_t, 0, "kd, out+=kd*diff(err)",             0, -30, 30)
gen.add("km_vel",     double_t, 0, "km, out+=km*des",                   0,   0, 300)
gen.add("umbral_vel", double_t, 0, "if err<umbral then err=0 ",         0,   0, 1)
gen.add("ki_dec_vel", double_t, 0, "ki reverse penalty mode",           0,   0, 30)
gen.add("range_vel",  double_t, 0, "max pwm in mode",                   0,   0, 30)

gen.add("P0", 	double_t, 0, "P0",    10, 0, 100)
gen.add("Q", 	double_t, 0, "Q",     10, 0, 100)
gen.add("R",    double_t, 0, "R",     10, 0, 100)
gen.add("rate", double_t, 0, "rate",  10, 0, 100)

gen.add("umbralki", double_t, 0, "umbralki", 0, 0, 1)
gen.add("umbralonoff", double_t, 0, "umbralonoff", 0, 0, 1)

exit(gen.generate(PACKAGE, "volti", "VOL"))
